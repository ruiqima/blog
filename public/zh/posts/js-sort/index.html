<!doctype html><html lang=zh><meta charset=utf-8><meta name=viewport content="width=device-width"><title>JavaScript排序算法 | RQ MA</title><meta name=generator content="Hugo Eureka 0.8.0"><link rel=stylesheet href=/css/eureka.min.css><script defer src=/js/eureka.min.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload="this.onload=null,this.rel='stylesheet'"><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css media=print onload="this.media='all',this.onload=null" crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js integrity="sha256-uNYoXefWRqv+PsIF/OflNmwtKM4lStn9yrz2gVl6ymo=" crossorigin></script><link rel=icon type=image/png sizes=32x32 href=/images/icon_hufe282a50f3886d4604387e18d88a80ad_43066_32x32_fill_box_center_2.png><link rel=apple-touch-icon sizes=180x180 href=/images/icon_hufe282a50f3886d4604387e18d88a80ad_43066_180x180_fill_box_center_2.png><meta name=description content="冒泡排序 基础 思路： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/zh/posts/"},{"@type":"ListItem","position":2,"name":"JavaScript排序算法","item":"/zh/posts/js-sort/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/zh/posts/js-sort/"},"headline":"JavaScript排序算法 | RQ MA","datePublished":"2021-05-12T17:29:57+08:00","dateModified":"2021-05-12T17:29:57+08:00","wordCount":1463,"publisher":{"@type":"Person","name":"Example publisher","logo":{"@type":"ImageObject","url":"/images/icon.png"}},"description":"冒泡排序 基础 思路： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的"}</script><meta property="og:title" content="JavaScript排序算法 | RQ MA"><meta property="og:type" content="article"><meta property="og:image" content="/images/icon.png"><meta property="og:url" content="/zh/posts/js-sort/"><meta property="og:description" content="冒泡排序 基础 思路： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的"><meta property="og:locale" content="zh"><meta property="og:site_name" content="RQ MA"><meta property="article:published_time" content="2021-05-12T17:29:57+08:00"><meta property="article:modified_time" content="2021-05-12T17:29:57+08:00"><meta property="article:section" content="posts"><body class="flex flex-col min-h-screen"><header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm"><div class="w-full max-w-screen-xl mx-auto"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=='Auto'||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName('html')[0].classList.add('dark')</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/zh class="mr-6 text-primary-text text-xl font-bold">RQ MA</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/zh/#about class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent mr-4">About</a>
<a href=/zh/posts/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 selected-menu-item mr-4">Posts</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-adjust"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>浅色</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>深色</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>自动</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById('lightDarkMode');storageColorScheme==null||storageColorScheme=='Auto'?document.addEventListener('DOMContentLoaded',()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change',switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'sun'),element.firstElementChild.classList.add('fa-sun')):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'moon'),element.firstElementChild.classList.add('fa-moon')),document.addEventListener('DOMContentLoaded',()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="flex-grow pt-16"><div class=pl-scrollbar><div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto"><div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12"><div class="col-span-2 lg:col-span-6 bg-secondary-bg rounded px-6 py-8"><h1 class="font-bold text-3xl text-primary-text">JavaScript排序算法</h1><div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text"><div class="mr-6 my-2"><i class="fas fa-calendar mr-1"></i>
<span>2021-05-12</span></div><div class="mr-6 my-2"><i class="fas fa-clock mr-1"></i>
<span>3分钟阅读时长</span></div></div><div class=content><h2 id=冒泡排序>冒泡排序</h2><h3 id=基础>基础</h3><p>思路：</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p><a href=https://github.com/MisterBooo/Article#12-%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA>动画演示</a></p><pre><code class=language-js>function bubbleSort(arr) {
    for (var i = 0; i &lt; arr.length - 1; i++) {
        for (var j = 0; j &lt; arr.length - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
</code></pre><p>备注：<br>每次都从第一个元素开始比较，所以<code>i</code>和<code>j</code>都是从<code>0</code>开始的。是每次都会在数组最后多一个已经排好了序的元素。</p><h3 id=优化>优化</h3><p>优化方向：</p><ul><li>每次循环最大的元素都会被放到最后，因此下一次循环可以不再比较这些元素。</li><li>当某次循环中没有任何元素进行互换时，说明排序已经完成，不必再进行接下来的循环。</li></ul><pre><code class=language-js>function optimizedBubbleSort(arr) {
    for (var i = 0; i &lt; arr.length - 1; i++) {
        let swapped = false;
        for (var j = 0; j &lt; arr.length - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        if (!swapped) {
            break;
        }
    }
}
</code></pre><h2 id=插入排序>插入排序</h2><ul><li>将第一个待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。</li></ul><pre><code class=language-js>function insertionSort(arr){
    if(arr.length==1){
        return arr;
    }else{
        for(var i=1;i&lt;arr.length;i++){
            for(var j=0;j&lt;i;j++){
                if(arr[j]&gt;=arr[i]){
                    var temp=arr[i];
                    arr.splice(i,1);
                    arr.splice(j,0,temp);
                }
            }
        }   
        return arr;
    }
}
</code></pre><h2 id=选择排序>选择排序</h2><ul><li>在未排序序列中找到最小（大）元素，与未排序序列的第一个元素进行互换。即，放到了已排序序列的末端。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，与未排序序列的第一个元素进行互换。</li><li>重复第二步，直到所有元素均排序完毕。</li></ul><pre><code class=language-js>function selectionSort(arr){
    for(var i=0;i&lt;arr.length-1;i++){
        // 记录未排序序列的第一个元素位置
        let currentIndex=i;
        let min=arr[currentIndex];
        let minIndex=currentIndex;
        // 从未排序序列中找到最小元素并记录其位置
        for(var j=i+1;j&lt;arr.length;j++){
            if(arr[j]&lt;min){
                minIndex=j;
                min=arr[j];
            }
        }
        // 交换未排序序列的第一个元素和最小元素
        let temp=arr[minIndex];
        arr[minIndex]=arr[currentIndex];
        arr[currentIndex]=temp;
    }
}
</code></pre><h2 id=快速排序>快速排序</h2><ul><li>随机选取数组中的一个数作为基数<code>pivot</code>（可以简单地选择最后一个元素）</li><li>将比<code>pivot</code>大的元素全部移到<code>pivot</code>左边，比<code>pivot</code>大的元素全部移到<code>pivot</code>的右边。以选取最后一个元素为<code>pivot</code>为例。<ul><li>使用下标<code>i</code>记录分界线：在<code>i</code>之前（包括<code>i</code>）的元素的值都小于<code>pivot</code>，在<code>i</code>之后的元素是大于等于<code>pivot</code>元素和未分类元素</li><li>使用<code>j</code>记录当前检查的未分类元素：在<code>j</code>之前的元素都已被分类</li><li>即，<code>i</code>之前（包括<code>i</code>）是比<code>pivot</code>小的元素，在<code>i</code>和<code>j</code>（不包括<code>j</code>）之间是比<code>pivot</code>大的元素，在<code>j</code>之后（包括<code>j</code>）是未分类的元素</li><li>当<code>j</code>的元素小于<code>pivot</code>时，这个元素应该被放到比<code>pivot</code>小的元素序列的末尾。因此，将<code>j</code>处元素与<code>i+1</code>处元素进行互换，并且<code>i++</code>。此时的<code>i</code>又指向了比<code>pivot</code>小的元素序列的末尾</li><li>当<code>j</code>的元素大于等于<code>pivot</code>时，这个元素本来就应该在<code>i</code>的右边，所以不需要进行更多操作。此时<code>j++</code>，继续将下一个元素分类</li><li>当<code>j==r</code>，即<code>j</code>已经扫描到了<code>pivot</code>所在位置时，<code>pivot</code>之前的元素都已经被分类，大小界限之分是在<code>i</code>和<code>i+1</code>之间。此时，将<code>pivot</code>值与<code>i+1</code>处值进行交换，使得<code>pivot</code>值的左边的值都比它小，右边的值都比它大。本次分类结束。</li></ul></li><li>再对原<code>pivot</code>左边的序列和右边的序列都进行分类操作。</li><li>当需要被分类的序列的长度小于等于1时，分类操作结束。</li></ul><p>这是分治的思想。</p><pre><code class=language-js>function quickSort(arr, l, r) {
    if (l &gt;= r) {
        return;
    } else {
        p = partition(arr, l, r);
        // 当原pivot没有被换到第一个或第二个元素处
        // 否则没有左边需要被排序
        if (p &gt; 1) {
            quickSort(arr, l, p - 1);
        }
        // 当原pivot没有被换到倒数第一个或倒数第二个元素处
        // 否则没有右边需要被排序
        if (p &lt; arr.length - 2) {
            quickSort(arr, p + 1, r);

        }
    }
}

function partition(arr, l, r) {
    // 选择最后一个元素作为本次的pivot
    let pivot = arr[r];
    let i = l - 1;
    for (var j = l; j &lt; r; j++) {
        if (arr[j] &lt; pivot) {
            i++;
            let temp = arr[j];
            arr[j] = arr[i];
            arr[i] = temp;
        }
    }
    let temp = pivot;
    arr[r] = arr[i + 1];
    arr[i + 1] = temp;
    return i + 1;
}
</code></pre></div><div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t"><div></div><div class="md:text-right mt-4 md:mt-0"><span class="block font-bold">下一页</span>
<a href=/zh/posts/js-array/ class=block>JavaScript数组操作方法</a></div></div><script id=utterances src=https://utteranc.es/client.js issue-term=pathname repo=ruiqima/comments theme=preferred-color-scheme crossorigin=anonymous async></script><script>((storageColorScheme=='Auto'||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementById('utterances').setAttribute('theme','github-dark')</script></div><div class=col-span-2><div class="sticky top-16 z-10 hidden lg:block px-6 py-4 bg-primary-bg"><span class="text-lg font-semibold">本页内容</span></div><div class="sticky-toc hidden lg:block px-6 pb-6"><nav id=TableOfContents><ul><li><a href=#冒泡排序>冒泡排序</a><ul><li><a href=#基础>基础</a></li><li><a href=#优化>优化</a></li></ul></li><li><a href=#插入排序>插入排序</a></li><li><a href=#选择排序>选择排序</a></li><li><a href=#快速排序>快速排序</a></li></ul></nav></div><script>window.addEventListener('DOMContentLoaded',()=>{enableStickyToc()})</script></div></div><script>document.addEventListener('DOMContentLoaded',()=>{hljs.initHighlightingOnLoad()})</script></div></div></main><footer class=pl-scrollbar><div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2021 Ruiqi Ma &#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>