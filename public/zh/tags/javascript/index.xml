<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JavaScript on RQ MA</title><link>/zh/tags/javascript/</link><description>Recent content in JavaScript on RQ MA</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy; {year} Ruiqi Ma</copyright><lastBuildDate>Tue, 28 Apr 2020 23:22:42 +0800</lastBuildDate><atom:link href="/zh/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript属性类型</title><link>/zh/posts/js-properties/</link><pubDate>Tue, 28 Apr 2020 23:22:42 +0800</pubDate><guid>/zh/posts/js-properties/</guid><description>数据属性 访问器属性 读取属性的特性 判断是否包含某属性和 in 操作符 获取属性 for-in——所有枚举属性 Object.keys()——可枚举实例属性的字符串数</description></item><item><title>JavaScript函数的定义及使用</title><link>/zh/posts/js-function/</link><pubDate>Mon, 27 Apr 2020 20:34:45 +0800</pubDate><guid>/zh/posts/js-function/</guid><description>定义函数 函数声明 函数表达式 函数的使用 作为其他函数参数 作为其他函数的返回值 递归 执行环境、作用域链、活动对象 闭包 定义函数 定义函数有两种方式，总结这两种定义</description></item><item><title>JavaScript继承方法详解</title><link>/zh/posts/js-inherit/</link><pubDate>Sat, 25 Apr 2020 21:22:22 +0800</pubDate><guid>/zh/posts/js-inherit/</guid><description>new 操作的实现原理 使用原型链进行继承 instanceof 操作符、isPrototypeOf() 方法 问题 借用构造函数 问题 组合继承 不足：会调用两次超类型构造函数 原型式继承 寄生</description></item><item><title>JavaScript创建对象模式</title><link>/zh/posts/js-createobj/</link><pubDate>Sat, 25 Apr 2020 17:06:58 +0800</pubDate><guid>/zh/posts/js-createobj/</guid><description>工厂模式 构造函数模式 原型模式 原型与原型链 构造函数、原型和实例的关系 原型的动态性 原型模式的缺点 组合使用构造函数模式和原型模式（用得最多） 动态原型模式 寄生</description></item><item><title>script加载方式以及元素属性</title><link>/zh/posts/js-load-script/</link><pubDate>Thu, 23 Apr 2020 15:05:39 +0800</pubDate><guid>/zh/posts/js-load-script/</guid><description>解释器对&amp;lt;script&amp;gt;中内容的加载方式 解析嵌入式JavaScript代码：在解释器对&amp;lt;script&amp;gt;;元素内部的所有代码求值</description></item></channel></rss>